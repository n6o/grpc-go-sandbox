// Code generated by MockGen. DO NOT EDIT.
// Source: ./gen-client/proto/api_grpc.pb.go

// Package gen_client is a generated GoMock package.
package gen_client

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	grpc "google.golang.org/grpc"
)

// MockEchoClient is a mock of EchoClient interface.
type MockEchoClient struct {
	ctrl     *gomock.Controller
	recorder *MockEchoClientMockRecorder
}

// MockEchoClientMockRecorder is the mock recorder for MockEchoClient.
type MockEchoClientMockRecorder struct {
	mock *MockEchoClient
}

// NewMockEchoClient creates a new mock instance.
func NewMockEchoClient(ctrl *gomock.Controller) *MockEchoClient {
	mock := &MockEchoClient{ctrl: ctrl}
	mock.recorder = &MockEchoClientMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEchoClient) EXPECT() *MockEchoClientMockRecorder {
	return m.recorder
}

// CallMountain mocks base method.
func (m *MockEchoClient) CallMountain(ctx context.Context, in *CallMountainRequest, opts ...grpc.CallOption) (*CallMountainResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CallMountain", varargs...)
	ret0, _ := ret[0].(*CallMountainResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CallMountain indicates an expected call of CallMountain.
func (mr *MockEchoClientMockRecorder) CallMountain(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CallMountain", reflect.TypeOf((*MockEchoClient)(nil).CallMountain), varargs...)
}

// Echo mocks base method.
func (m *MockEchoClient) Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, in}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Echo", varargs...)
	ret0, _ := ret[0].(*EchoResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Echo indicates an expected call of Echo.
func (mr *MockEchoClientMockRecorder) Echo(ctx, in interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, in}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Echo", reflect.TypeOf((*MockEchoClient)(nil).Echo), varargs...)
}

// MockEchoServer is a mock of EchoServer interface.
type MockEchoServer struct {
	ctrl     *gomock.Controller
	recorder *MockEchoServerMockRecorder
}

// MockEchoServerMockRecorder is the mock recorder for MockEchoServer.
type MockEchoServerMockRecorder struct {
	mock *MockEchoServer
}

// NewMockEchoServer creates a new mock instance.
func NewMockEchoServer(ctrl *gomock.Controller) *MockEchoServer {
	mock := &MockEchoServer{ctrl: ctrl}
	mock.recorder = &MockEchoServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEchoServer) EXPECT() *MockEchoServerMockRecorder {
	return m.recorder
}

// CallMountain mocks base method.
func (m *MockEchoServer) CallMountain(arg0 context.Context, arg1 *CallMountainRequest) (*CallMountainResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CallMountain", arg0, arg1)
	ret0, _ := ret[0].(*CallMountainResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CallMountain indicates an expected call of CallMountain.
func (mr *MockEchoServerMockRecorder) CallMountain(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CallMountain", reflect.TypeOf((*MockEchoServer)(nil).CallMountain), arg0, arg1)
}

// Echo mocks base method.
func (m *MockEchoServer) Echo(arg0 context.Context, arg1 *EchoRequest) (*EchoResponse, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Echo", arg0, arg1)
	ret0, _ := ret[0].(*EchoResponse)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Echo indicates an expected call of Echo.
func (mr *MockEchoServerMockRecorder) Echo(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Echo", reflect.TypeOf((*MockEchoServer)(nil).Echo), arg0, arg1)
}

// mustEmbedUnimplementedEchoServer mocks base method.
func (m *MockEchoServer) mustEmbedUnimplementedEchoServer() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "mustEmbedUnimplementedEchoServer")
}

// mustEmbedUnimplementedEchoServer indicates an expected call of mustEmbedUnimplementedEchoServer.
func (mr *MockEchoServerMockRecorder) mustEmbedUnimplementedEchoServer() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedEchoServer", reflect.TypeOf((*MockEchoServer)(nil).mustEmbedUnimplementedEchoServer))
}

// MockUnsafeEchoServer is a mock of UnsafeEchoServer interface.
type MockUnsafeEchoServer struct {
	ctrl     *gomock.Controller
	recorder *MockUnsafeEchoServerMockRecorder
}

// MockUnsafeEchoServerMockRecorder is the mock recorder for MockUnsafeEchoServer.
type MockUnsafeEchoServerMockRecorder struct {
	mock *MockUnsafeEchoServer
}

// NewMockUnsafeEchoServer creates a new mock instance.
func NewMockUnsafeEchoServer(ctrl *gomock.Controller) *MockUnsafeEchoServer {
	mock := &MockUnsafeEchoServer{ctrl: ctrl}
	mock.recorder = &MockUnsafeEchoServerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeEchoServer) EXPECT() *MockUnsafeEchoServerMockRecorder {
	return m.recorder
}

// mustEmbedUnimplementedEchoServer mocks base method.
func (m *MockUnsafeEchoServer) mustEmbedUnimplementedEchoServer() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "mustEmbedUnimplementedEchoServer")
}

// mustEmbedUnimplementedEchoServer indicates an expected call of mustEmbedUnimplementedEchoServer.
func (mr *MockUnsafeEchoServerMockRecorder) mustEmbedUnimplementedEchoServer() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedEchoServer", reflect.TypeOf((*MockUnsafeEchoServer)(nil).mustEmbedUnimplementedEchoServer))
}
